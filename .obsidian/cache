{"files":{"Root.md":{"mtime":1590807824790.7764,"size":127,"hash":"dc31bbec980e3c675fb548bab49cc7fd4f69f7a58078a1ef096d22e88728186a"},"Nested/Discrete Math.md":{"mtime":1590714885286.6177,"size":485,"hash":"11b8af12b956a8c4cae301446b71ae57bc912278e1e985ac8287f23277c118aa"},"Nested/Permutations and Combinations.md":{"mtime":1590714280485.7834,"size":243,"hash":"43b8568bdcd9d42ce776083b68bf23b4fabfa6eb751ab100edace51986bfa386"},"Nested/Software Analysis.md":{"mtime":1590714517032.02,"size":252,"hash":"bc4717db19d0c0ce356cfc4af647ffa2fd47f8e0dcce0dfb463b4829777450ad"},"Nested/Software Reliability.md":{"mtime":1590714665474.8987,"size":162,"hash":"e59535f59a5faa5efff9751d92c7ccdc318956514a4b60e97eff40fcca7fb97b"},"Nested/Software Design.md":{"mtime":1590805798459.4458,"size":253,"hash":"66834dee8feb9847052f2cc2e9f391639d2fb46248b0575f26e7579b7e831ac4"},"Nested/Full Stack Architecture.md":{"mtime":1590808077021.9468,"size":1783,"hash":"d82759607c98cf213c525dd1e8a662c35b3ea8dc17ff7d7569f9324e9cbdde15"},"Nested/Refactoring.md":{"mtime":1590864634271.8218,"size":1014,"hash":"287bf2ac63a2d7bf95f98dd68c6a5b1fb13e1eb5fd6cc75fe09c588e810e6999"},"Nested/Decisions and Time.md":{"mtime":1590806650345.332,"size":1003,"hash":"f0b7e2aeeead8ead7319f68751829c1d123490ce25cded69cfc94c9dd6d9400f"},"Nested/Probability.md":{"mtime":1590806450232.4395,"size":203,"hash":"7e679cdceb4cd4cd9eacf754eac20b06618a9ad96ce48c4aab34c081133fe7d9"},"Nested/Use Cases.md":{"mtime":1590807968701.7827,"size":579,"hash":"6f57aaa44fb1f2090a7f430b08797a21e4224e737b2aba491cb03724ef48dab6"},"Topics/Root.md":{"mtime":1590808229796.2134,"size":63,"hash":"b07397c330591a1aadd12aab5f88cd9f2ac9e9288a2a74166226e7e7546b4cc6"},"Topics/Test Data Selection.md":{"mtime":1590886188448.8965,"size":5190,"hash":"0a6212932b398ef403fb548a099e03fbd12f8fa3c2b698bdc9a0552835ae6a89"},"Nested/Test Case Migrations.md":{"mtime":1590864708848.7375,"size":1656,"hash":"2f61a24d07539a3a0b96f4abca7c3e7942b983757579af017b7bb9cb343ccae0"}},"metadata":{"43b8568bdcd9d42ce776083b68bf23b4fabfa6eb751ab100edace51986bfa386":{"links":[],"embeds":[],"tags":[],"headings":[]},"bc4717db19d0c0ce356cfc4af647ffa2fd47f8e0dcce0dfb463b4829777450ad":{"links":[],"embeds":[],"tags":[],"headings":[]},"e59535f59a5faa5efff9751d92c7ccdc318956514a4b60e97eff40fcca7fb97b":{"links":[{"line":0,"link":"Software Analysis","original":"[[Software Analysis]]","displayText":"","beforeContext":"Current software is hopelessly unreliable. It’s no surprise, given the results that ","afterContext":" show us: programs become complicated extremely quickly."}],"embeds":[],"tags":[],"headings":[]},"11b8af12b956a8c4cae301446b71ae57bc912278e1e985ac8287f23277c118aa":{"links":[{"line":0,"link":"Permutations and Combinations","original":"[[Permutations and Combinations]]","displayText":"","beforeContext":"","afterContext":" show up all over the place. For example, the universe of behaviors of a program is equal to all of the paths through the program for all of the combinations of all inputs."}],"embeds":[],"tags":[],"headings":[]},"66834dee8feb9847052f2cc2e9f391639d2fb46248b0575f26e7579b7e831ac4":{"links":[{"line":2,"link":"Full Stack Architecture","original":"[[Full Stack Architecture]]","displayText":"","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"7e679cdceb4cd4cd9eacf754eac20b06618a9ad96ce48c4aab34c081133fe7d9":{"links":[],"embeds":[],"tags":[],"headings":[]},"f0b7e2aeeead8ead7319f68751829c1d123490ce25cded69cfc94c9dd6d9400f":{"links":[],"embeds":[],"tags":[],"headings":[]},"dc31bbec980e3c675fb548bab49cc7fd4f69f7a58078a1ef096d22e88728186a":{"links":[{"line":0,"link":"Software Analysis","original":"[[Software Analysis]]","displayText":"","beforeContext":"","afterContext":""},{"line":2,"link":"Software Reliability","original":"[[Software Reliability]]","displayText":"","beforeContext":"","afterContext":""},{"line":4,"link":"Software Design","original":"[[Software Design]]","displayText":"","beforeContext":"","afterContext":""},{"line":6,"link":"Use Cases","original":"[[Use Cases]]","displayText":"","beforeContext":"","afterContext":""},{"line":8,"link":"Discrete Math","original":"[[Discrete Math]]","displayText":"","beforeContext":"","afterContext":""},{"line":10,"link":"Probability","original":"[[Probability]]","displayText":"","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"6f57aaa44fb1f2090a7f430b08797a21e4224e737b2aba491cb03724ef48dab6":{"links":[],"embeds":[],"tags":[],"headings":[]},"d82759607c98cf213c525dd1e8a662c35b3ea8dc17ff7d7569f9324e9cbdde15":{"links":[{"line":3,"link":"Refactoring","original":"[[Refactoring]]","displayText":"","beforeContext":"Fore this reason, refactoring away from a client server architecture would be very costly, because this assumption is everywhere in the code (","afterContext":")"},{"line":11,"link":"Use Cases","original":"[[Use Cases]]","displayText":"","beforeContext":"The main impact of a client-server architecture is that the ","afterContext":" are now separated into two parts. You can’t carry out a use case with just the client or the server, you need both."}],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Client-server","level":1}]},"b07397c330591a1aadd12aab5f88cd9f2ac9e9288a2a74166226e7e7546b4cc6":{"links":[],"embeds":[],"tags":[],"headings":[]},"287bf2ac63a2d7bf95f98dd68c6a5b1fb13e1eb5fd6cc75fe09c588e810e6999":{"links":[{"line":0,"link":"Decisions and Time","original":"[[Decisions and Time]]","displayText":"","beforeContext":"Refactoring is very tricky, because your ability to refactor depends on the state of the tests. If the tests are too coupled to the implementation, you will need to change the tests along with the implementation code. This will make the change more time consuming, as it will involve more decisions: ","afterContext":"."},{"line":2,"link":"Probability","original":"[[Probability]]","displayText":"","beforeContext":"I wonder how to make tests less fragile. I think it has something to do with the black swan effect: ","afterContext":", i.e. the more costly a change is to make, the more we should plan for it to happen. Because even if it is improbable, the cost if it does happen is very high."},{"line":6,"link":"Test Case Migrations","original":"[[Test Case Migrations]]","displayText":"","beforeContext":"","afterContext":"What if there is a way to have both sets of tests, but only use one or the other depending on the refactoring task you’re doing?"}],"embeds":[],"tags":[],"headings":[]},"2f61a24d07539a3a0b96f4abca7c3e7942b983757579af017b7bb9cb343ccae0":{"links":[],"embeds":[],"tags":[],"headings":[]},"0a6212932b398ef403fb548a099e03fbd12f8fa3c2b698bdc9a0552835ae6a89":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"How to best select test inputs?","level":1},{"line":9,"heading":"What is a program?","level":1},{"line":75,"heading":"The Futility of Exhaustive Testing","level":1},{"line":86,"heading":"Common Sense Partitions","level":1},{"line":97,"heading":"Composite Types: Product and Sum Types","level":1},{"line":129,"heading":"It's all about the inputs","level":1},{"line":134,"heading":"The Tests I'd Write","level":1},{"line":145,"heading":"Frontend table:","level":3},{"line":181,"heading":"Backend Table:","level":3},{"line":193,"heading":"Advice","level":1}]}},"algorithmVersion":6}