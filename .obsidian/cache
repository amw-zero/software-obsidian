{"files":{"Nested/Control Flow Graph.md":{"mtime":1591125988707.7852,"size":684,"hash":"67387c1bd8c73d6c6daab5b829467e8c53897c8aa664b43c7b8bbdc8aff3b28f"},"Nested/Decisions and Time.md":{"mtime":1590806650345.332,"size":1003,"hash":"f0b7e2aeeead8ead7319f68751829c1d123490ce25cded69cfc94c9dd6d9400f"},"Nested/Discrete Math.md":{"mtime":1590714885286.6177,"size":485,"hash":"11b8af12b956a8c4cae301446b71ae57bc912278e1e985ac8287f23277c118aa"},"Nested/Full Stack Architecture.md":{"mtime":1591920922829.4592,"size":1796,"hash":"347287c27c5bd403cdd7dbe75f0562c4f3a8a124d147cbba5118129749397520"},"Nested/Permutations and Combinations.md":{"mtime":1590714280485.7834,"size":243,"hash":"43b8568bdcd9d42ce776083b68bf23b4fabfa6eb751ab100edace51986bfa386"},"Nested/Probability.md":{"mtime":1590806450232.4395,"size":203,"hash":"7e679cdceb4cd4cd9eacf754eac20b06618a9ad96ce48c4aab34c081133fe7d9"},"Nested/Refactoring.md":{"mtime":1591757722167.4812,"size":1014,"hash":"287bf2ac63a2d7bf95f98dd68c6a5b1fb13e1eb5fd6cc75fe09c588e810e6999"},"Nested/Software Analysis.md":{"mtime":1591759306254.0264,"size":341,"hash":"f1876902754e94fa9e20fdf5a97fba4ce0afd07b2fd708731a3a4d67982fafbf"},"Nested/Software Design.md":{"mtime":1590805798459.4458,"size":253,"hash":"66834dee8feb9847052f2cc2e9f391639d2fb46248b0575f26e7579b7e831ac4"},"Nested/Software Reliability.md":{"mtime":1592612765642.1172,"size":544,"hash":"9ccd8f89efabd76814e0e2438f085cbbf2447023b4c6434e6842e7ad539f99ed"},"Nested/Test Case Migrations.md":{"mtime":1590864708848.7375,"size":1656,"hash":"2f61a24d07539a3a0b96f4abca7c3e7942b983757579af017b7bb9cb343ccae0"},"Nested/Type Cardinality.md":{"mtime":1591126170880.6748,"size":736,"hash":"b025e5a09c8bba1ab3705b44f861317d90943896b8575b9da1730a5f2b6cfacc"},"Nested/Use Cases.md":{"mtime":1590807968701.7827,"size":579,"hash":"6f57aaa44fb1f2090a7f430b08797a21e4224e737b2aba491cb03724ef48dab6"},"Root.md":{"mtime":1590807824790.7764,"size":127,"hash":"dc31bbec980e3c675fb548bab49cc7fd4f69f7a58078a1ef096d22e88728186a"},"Topics/Root.md":{"mtime":1590808229796.2134,"size":63,"hash":"b07397c330591a1aadd12aab5f88cd9f2ac9e9288a2a74166226e7e7546b4cc6"},"Topics/Test Data Selection.md":{"mtime":1593144553057.855,"size":19088,"hash":"cbc8129d9fab1aaae87099613dc5f62b9158e86d69060339d5163dae79a65071"},"Topics/Shared Mutable State.md":{"mtime":1591411172304.9373,"size":785,"hash":"e3baeca24bd7b69a47a4961dfc9b41b3cd0a627441b9418dea23c58499c232ca"},"Nested/Programming vs. Math.md":{"mtime":1591413423265.3884,"size":292,"hash":"5179f89e6cdb516ae803b6841dbee5981d26dfcd1efc31f1690a09c8783b2762"},"Nested/System Archetypes.md":{"mtime":1591759598016.5789,"size":589,"hash":"2f31c3fa9bd8059ed7d2b500dcc2724ea669f581268408591578b555d2f51b0f"},"Nested/Randomized Exploratory Testing.md":{"mtime":1591923016318.1445,"size":87,"hash":"f8b113026b8e542a1cb26616bd12748b3cf57ec09cb7ca23c1d2729af87fe4ac"},"Nested/Effective Testing.md":{"mtime":1592615565930.8691,"size":1373,"hash":"3a29349c3e99ee78327d45341fdbcf1f4c1c000afe743deaf67345f2da60a81c"},"Nested/System Boundaries.md":{"mtime":1592612625658.737,"size":0,"hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"}},"metadata":{"67387c1bd8c73d6c6daab5b829467e8c53897c8aa664b43c7b8bbdc8aff3b28f":{"links":[{"line":5,"link":"Type Cardinality","original":"[[Type Cardinality]]","displayText":"","beforeContext":"Knowing the type of value that flows along the edge is useful, because from the type you can know the full set of values that the type can represent. ","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"f0b7e2aeeead8ead7319f68751829c1d123490ce25cded69cfc94c9dd6d9400f":{"links":[],"embeds":[],"tags":[],"headings":[]},"11b8af12b956a8c4cae301446b71ae57bc912278e1e985ac8287f23277c118aa":{"links":[{"line":0,"link":"Permutations and Combinations","original":"[[Permutations and Combinations]]","displayText":"","beforeContext":"","afterContext":" show up all over the place. For example, the universe of behaviors of a program is equal to all of the paths through the program for all of the combinations of all inputs."}],"embeds":[],"tags":[],"headings":[]},"43b8568bdcd9d42ce776083b68bf23b4fabfa6eb751ab100edace51986bfa386":{"links":[],"embeds":[],"tags":[],"headings":[]},"7e679cdceb4cd4cd9eacf754eac20b06618a9ad96ce48c4aab34c081133fe7d9":{"links":[],"embeds":[],"tags":[],"headings":[]},"287bf2ac63a2d7bf95f98dd68c6a5b1fb13e1eb5fd6cc75fe09c588e810e6999":{"links":[{"line":0,"link":"Decisions and Time","original":"[[Decisions and Time]]","displayText":"","beforeContext":"Refactoring is very tricky, because your ability to refactor depends on the state of the tests. If the tests are too coupled to the implementation, you will need to change the tests along with the implementation code. This will make the change more time consuming, as it will involve more decisions: ","afterContext":"."},{"line":2,"link":"Probability","original":"[[Probability]]","displayText":"","beforeContext":"I wonder how to make tests less fragile. I think it has something to do with the black swan effect: ","afterContext":", i.e. the more costly a change is to make, the more we should plan for it to happen. Because even if it is improbable, the cost if it does happen is very high."},{"line":6,"link":"Test Case Migrations","original":"[[Test Case Migrations]]","displayText":"","beforeContext":"","afterContext":"What if there is a way to have both sets of tests, but only use one or the other depending on the refactoring task you’re doing?"}],"embeds":[],"tags":[],"headings":[]},"66834dee8feb9847052f2cc2e9f391639d2fb46248b0575f26e7579b7e831ac4":{"links":[{"line":2,"link":"Full Stack Architecture","original":"[[Full Stack Architecture]]","displayText":"","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"2f61a24d07539a3a0b96f4abca7c3e7942b983757579af017b7bb9cb343ccae0":{"links":[],"embeds":[],"tags":[],"headings":[]},"b025e5a09c8bba1ab3705b44f861317d90943896b8575b9da1730a5f2b6cfacc":{"links":[],"embeds":[],"tags":[],"headings":[]},"6f57aaa44fb1f2090a7f430b08797a21e4224e737b2aba491cb03724ef48dab6":{"links":[],"embeds":[],"tags":[],"headings":[]},"dc31bbec980e3c675fb548bab49cc7fd4f69f7a58078a1ef096d22e88728186a":{"links":[{"line":0,"link":"Software Analysis","original":"[[Software Analysis]]","displayText":"","beforeContext":"","afterContext":""},{"line":2,"link":"Software Reliability","original":"[[Software Reliability]]","displayText":"","beforeContext":"","afterContext":""},{"line":4,"link":"Software Design","original":"[[Software Design]]","displayText":"","beforeContext":"","afterContext":""},{"line":6,"link":"Use Cases","original":"[[Use Cases]]","displayText":"","beforeContext":"","afterContext":""},{"line":8,"link":"Discrete Math","original":"[[Discrete Math]]","displayText":"","beforeContext":"","afterContext":""},{"line":10,"link":"Probability","original":"[[Probability]]","displayText":"","beforeContext":"","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"b07397c330591a1aadd12aab5f88cd9f2ac9e9288a2a74166226e7e7546b4cc6":{"links":[],"embeds":[],"tags":[],"headings":[]},"e3baeca24bd7b69a47a4961dfc9b41b3cd0a627441b9418dea23c58499c232ca":{"links":[],"embeds":[],"tags":[],"headings":[]},"5179f89e6cdb516ae803b6841dbee5981d26dfcd1efc31f1690a09c8783b2762":{"links":[],"embeds":[],"tags":[],"headings":[]},"f1876902754e94fa9e20fdf5a97fba4ce0afd07b2fd708731a3a4d67982fafbf":{"links":[{"line":0,"link":"Control Flow Graph","original":"[[Control Flow Graph]]","displayText":"","beforeContext":"Ultimately, a program is a ","afterContext":" that a set of inputs traverses. The set of all inputs traversing through the graph determines the full behavior of the program."},{"line":4,"link":"System Archetypes","original":"[[System Archetypes]]","displayText":"","beforeContext":"Control flow graphs fall into categories as well, according to ","afterContext":""}],"embeds":[],"tags":[],"headings":[]},"2f31c3fa9bd8059ed7d2b500dcc2724ea669f581268408591578b555d2f51b0f":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Information System","level":1},{"line":5,"heading":"Algorithmic System","level":1}]},"347287c27c5bd403cdd7dbe75f0562c4f3a8a124d147cbba5118129749397520":{"links":[{"line":3,"link":"Refactoring","original":"[[Refactoring]]","displayText":"","beforeContext":"Fore this reason, refactoring away from a client server architecture would be very costly, because this assumption is everywhere in the code (","afterContext":")"},{"line":11,"link":"Use Cases","original":"[[Use Cases]]","displayText":"","beforeContext":"The main impact of a client-server architecture is that the ","afterContext":" are now separated into two parts. You can’t carry out a use case with just the client or the server, you need both."}],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Client-server","level":1},{"line":15,"heading":"Visually","level":1}]},"f8b113026b8e542a1cb26616bd12748b3cf57ec09cb7ca23c1d2729af87fe4ac":{"links":[],"embeds":[],"tags":[],"headings":[]},"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855":{"links":[],"embeds":[],"tags":[],"headings":[]},"9ccd8f89efabd76814e0e2438f085cbbf2447023b4c6434e6842e7ad539f99ed":{"links":[{"line":0,"link":"Software Analysis","original":"[[Software Analysis]]","displayText":"","beforeContext":"Current software is hopelessly unreliable. It’s no surprise, given the results that ","afterContext":" show us: programs become complicated extremely quickly. The number of possible inputs can be astronomical."},{"line":2,"link":"Randomized Exploratory Testing","original":"[[Randomized Exploratory Testing]]","displayText":"","beforeContext":"I see two main paths for getting reliable software: formal verification, and ","afterContext":"."},{"line":4,"link":"Effective Testing","original":"[[Effective Testing]]","displayText":"","beforeContext":"For reliablity over time,  ","afterContext":" is essential. Not only do test cases need to catch bugs when a change is happening, but they also can’t hamper refactoring too much, otherwise they are very costly."}],"embeds":[],"tags":[],"headings":[]},"3a29349c3e99ee78327d45341fdbcf1f4c1c000afe743deaf67345f2da60a81c":{"links":[],"embeds":[],"tags":[],"headings":[]},"1d8f839490f76e8b57ae399d4626c02f290ddc92b54ef1c4a45c11d075546723":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Delivering Mail","level":1},{"line":7,"heading":"Pattern Language","level":1},{"line":21,"heading":"How to best select test inputs?","level":1},{"line":30,"heading":"What is a program?","level":1},{"line":85,"heading":"The Futility of Exhaustive Testing","level":1},{"line":96,"heading":"Composite Types: Product and Sum Types","level":1},{"line":128,"heading":"Tests for Everyday Features","level":1},{"line":130,"heading":"Permissioning","level":3},{"line":193,"heading":"Application / Networking Logic","level":3},{"line":206,"heading":"Frontend table:","level":3},{"line":333,"heading":"Key Takeaways:","level":4},{"line":343,"heading":"Backend Table:","level":3},{"line":394,"heading":"Boundaries","level":1},{"line":413,"heading":"Common Sense Partitions","level":1},{"line":425,"heading":"It's all about the inputs","level":1},{"line":430,"heading":"In, Out, On, Off","level":1},{"line":434,"heading":"Advice","level":1},{"line":441,"heading":"What about the other stuff?","level":1},{"line":446,"heading":"Thoughts","level":1}]},"c0113b305bff6b8f95b5732e892585c746943711c109487a026ed8fa616cea8a":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Delivering Mail","level":1},{"line":7,"heading":"Pattern Language","level":1},{"line":21,"heading":"How to best select test inputs?","level":1},{"line":30,"heading":"What is a program?","level":1},{"line":85,"heading":"The Futility of Exhaustive Testing","level":1},{"line":96,"heading":"Composite Types: Product and Sum Types","level":1},{"line":128,"heading":"Tests for Everyday Features","level":1},{"line":130,"heading":"Permissioning","level":3},{"line":193,"heading":"Application / Networking Logic","level":3},{"line":206,"heading":"Frontend table:","level":3},{"line":333,"heading":"Key Takeaways:","level":4},{"line":343,"heading":"Backend Table:","level":3},{"line":394,"heading":"Boundaries","level":1},{"line":413,"heading":"Common Sense Partitions","level":1},{"line":425,"heading":"It's all about the inputs","level":1},{"line":430,"heading":"In, Out, On, Off","level":1},{"line":434,"heading":"Advice","level":1},{"line":441,"heading":"What about the other stuff?","level":1},{"line":446,"heading":"Thoughts","level":1}]},"707bd0c72fef62420652bc2a223915e1e0aa8dad149fd958ab151fd3856dd7f1":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Delivering Mail","level":1},{"line":7,"heading":"Pattern Language","level":1},{"line":21,"heading":"How to best select test inputs?","level":1},{"line":30,"heading":"What is a program?","level":1},{"line":85,"heading":"The Futility of Exhaustive Testing","level":1},{"line":96,"heading":"Composite Types: Product and Sum Types","level":1},{"line":128,"heading":"Tests for Everyday Features","level":1},{"line":130,"heading":"Permissioning","level":3},{"line":193,"heading":"Application / Networking Logic","level":3},{"line":206,"heading":"Frontend table:","level":3},{"line":333,"heading":"Key Takeaways:","level":4},{"line":343,"heading":"Backend Table:","level":3},{"line":394,"heading":"Boundaries","level":1},{"line":413,"heading":"Common Sense Partitions","level":1},{"line":425,"heading":"It's all about the inputs","level":1},{"line":430,"heading":"In, Out, On, Off","level":1},{"line":434,"heading":"Advice","level":1},{"line":441,"heading":"What about the other stuff?","level":1},{"line":446,"heading":"Thoughts","level":1}]},"d9a090e0953e5f0c204e039bb0251cd8c0d4be1b9cb9a75049353f46f51fd582":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Delivering Mail","level":1},{"line":7,"heading":"Pattern Language","level":1},{"line":21,"heading":"How to best select test inputs?","level":1},{"line":30,"heading":"What is a program?","level":1},{"line":85,"heading":"The Futility of Exhaustive Testing","level":1},{"line":96,"heading":"Composite Types: Product and Sum Types","level":1},{"line":128,"heading":"Tests for Everyday Features","level":1},{"line":130,"heading":"Permissioning","level":3},{"line":193,"heading":"Application / Networking Logic","level":3},{"line":206,"heading":"Frontend table:","level":3},{"line":333,"heading":"Key Takeaways:","level":4},{"line":343,"heading":"Backend Table:","level":3},{"line":394,"heading":"Boundaries","level":1},{"line":413,"heading":"Common Sense Partitions","level":1},{"line":425,"heading":"It's all about the inputs","level":1},{"line":430,"heading":"In, Out, On, Off","level":1},{"line":434,"heading":"Advice","level":1},{"line":441,"heading":"What about the other stuff?","level":1},{"line":446,"heading":"Thoughts","level":1}]},"cbc8129d9fab1aaae87099613dc5f62b9158e86d69060339d5163dae79a65071":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Delivering Mail","level":1},{"line":7,"heading":"Pattern Language","level":1},{"line":21,"heading":"How to best select test inputs?","level":1},{"line":30,"heading":"What is a program?","level":1},{"line":85,"heading":"The Futility of Exhaustive Testing","level":1},{"line":96,"heading":"Composite Types: Product and Sum Types","level":1},{"line":128,"heading":"Tests for Everyday Features","level":1},{"line":130,"heading":"Permissioning","level":3},{"line":193,"heading":"Application / Networking Logic","level":3},{"line":206,"heading":"Frontend table:","level":3},{"line":333,"heading":"Key Takeaways:","level":4},{"line":343,"heading":"Backend Table:","level":3},{"line":394,"heading":"Boundaries","level":1},{"line":413,"heading":"Common Sense Partitions","level":1},{"line":425,"heading":"It's all about the inputs","level":1},{"line":430,"heading":"In, Out, On, Off","level":1},{"line":434,"heading":"Advice","level":1},{"line":441,"heading":"What about the other stuff?","level":1},{"line":446,"heading":"Thoughts","level":1}]}},"algorithmVersion":9}